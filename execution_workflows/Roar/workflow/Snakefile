"""
Snakemake pipeline for APA-Scan.
For help see: https://snakemake.readthedocs.io/en/stable/index.html.
"""


# ------------------------------------------------------------------------------
# Packages, Libraries and Sources

import pandas as pd





# ------------------------------------------------------------------------------
# Config/Metadata

# Read in config file
configfile: "config/config.Roar.yaml"

# Convert config to dataframe
samples = pd.read_csv(os.path.abspath(config["samples"]),sep=",")





#-------------------------------------------------------------------------------
# Parameters, filenames & sample data


#### NOTES #####################################################################

# The input file patterns below are present in the samples.csv as their own
# column. They are patterns that match the filenames of files in a directory
# of one condition. So for the test files they're either "Srsf3" or "Control".
# Might be worth changing these especially if the files of the different
# conditions are kept separately.

################################################################################


# Parameters
THREADS = 8


# Input file patterns
CONDITION1 = samples["sample_type"].unique()[0]
CONDITION2 = samples["sample_type"].unique()[1]


# Output filename shorthands
PARAMCODE = "AA"
ROAR_OUTPUT = config["out_dir"] + "/" + PARAMCODE + "_Roar"


# This is the 3' UTR gtf file for the multiple APA site roar analysis (see
# section 3.6 of vignette)
ANNOTATION = config["gtf"]


# RScript outputs
RSCRIPT = os.path.join(config["scripts"], "Roar_polya.R")


# Print to compare conditions and check correct way round
print(">>>>> COMPARING: ")
print("   >> " + CONDITION1)
print("   >> " + CONDITION2)
print("   >> APA-Scan RAW OUTPUT IS :- " + config["out_dir"] + "/" + ROAR_OUTPUT)





# Final Target Rule ------------------------------------------------------------
localrules: finish

# Final output to .bed (format 01) and .tsv (format 03)

rule finish:
    """Rule that specifies the final output.
    """
    input:
        os.path.join(config["out_dir"], ROAR_OUTPUT + "_01.bed"),
        os.path.join(config["out_dir"], ROAR_OUTPUT + "_03.tsv")





#-------------------------------------------------------------------------------
# Run Roar

#### NOTES #####################################################################

# Below, the inputs are;
#   * rscript: R-script that runs Roar and outputs the final file formats
#   *     gtf: Filename for the anotation gtf of 3' UTRs
#   *    bam1: Test condition, which is a string that acts as a pattern to match
#              a subset of files that correspond to the files of the test
#              condition
#   *    bam2: Same as bam1 but for the other (control) condition.
#   *  output: A code that corresponds to the first part of the output file, ie
#              the parameter code (ie AA) and method (Roar)

################################################################################


rule run_roar_rscript:
    """This runs the Roar Rscript.
    """
    input:
        rscript=RSCRIPT,
        gtf=ANNOTATION
    output:
        os.path.join(config["out_dir"], ROAR_OUTPUT + "_01.bed"),
        os.path.join(config["out_dir"], ROAR_OUTPUT + "_03.tsv")
    threads: THREADS
    conda: os.path.join(config["envs"], "Roar.yaml")
    log:
        os.path.join(config["local_log"], "execute.roar_rscript.log")
    shell:
        "( Rscript {input.rscript}  " + \
                 " {input.gtf} " + \
                   CONDITION1 + " " + CONDITION2 + " " + \
                   ROAR_OUTPUT + " ) &> {log} "





#-------------------------------------------------------------------------------
# How did it go?
#-------------------------------------------------------------------------------
onsuccess:
    print("Workflow finished, no error")

onerror:
    print("An error occurred, check log at %s." % {log})
